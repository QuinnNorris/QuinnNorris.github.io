
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Gwon NyeongJin">
    <title>Map类数据结构分析 - Gwon NyeongJin</title>
    <meta name="author" content="Gwon NyeongJin">
    
    
        <link rel="icon" href="http://yoursite.com/assets/images/author.JPG">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Gwon NyeongJin","sameAs":["https://github.com/QuinnNorris","https://weibo.com/u/6556522860","https://blog.csdn.net/QuinnNorris","mailto:sei_qnz2015@126.com"],"image":"author.JPG"},"articleBody":"\n1 HashMapHashMap是基于哈希表的Map接口的非同步实现。使用者可以将数据按照key,value键值对应的形式向HashMap中存放数据。hashmap是一种用空间换时间的数据结构，如何去定义桶的大小，是最关键的要衡量的指标。如果桶过大，则空间浪费，如果桶过小，则会频繁发生冲突。\n1.2特性\n容量大小必须为2的幂，h &amp; (table.length -1) 等价于 h % table.length\n具有装载因子的概念，默认为0.75\n对key进行hash，调用key的hashcode函数并与其右移16位后的结果做异或\n对于用户声明的容量，HashMap的容量会变为大于此容量的最小的2的幂\nHashMap采用懒加载，put方法会依次进行：创建数组、是否扩容、添加数据的操作\n一般情况下，遇到哈希冲突可以采用开放定址法或者使用拉链法两种方法解决。HashMap采用拉链法解决冲突\n不保证映射的顺序，特别是它不保证该顺序恒久不变\n扩容非常方便，在一个桶中的数据会被存放在两个桶中\nHashMap中允许存放并使用null值和null键\n调用put方法，会计算其中put的key的对象的hashcode，通过类中的hash函数运算进行处理，处理后在桶中找到这个地址，存放进链表的尾部\nHashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)\n\n1.3 源代码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;    private static final long serialVersionUID = 362498820763181265L;    /**     * 容量大小必须为2的幂，原因是从jdk1.2开始之后计算机中除法、取模     * 运算操作效率越来越低，为了防止效率过低，设置容量大小为2的幂，     * 在进行取模时，用A&amp;（B-1）来代替A%B的操作，提高效率，至于hash分布     * 用其他的辅助方法确保效率     */    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16    /**     * 最大容量2的29次方     */    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;    /**     * 加载因子     */    static final float DEFAULT_LOAD_FACTOR = 0.75f;    static final int TREEIFY_THRESHOLD = 8;    static final int UNTREEIFY_THRESHOLD = 6;    static final int MIN_TREEIFY_CAPACITY = 64;    /**     * hashMap桶中的数据结构是Node，next是下一个Node的引用     */    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;        final int hash;        final K key;        V value;        Node&lt;K,V&gt; next;        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;            this.hash = hash;            this.key = key;            this.value = value;            this.next = next;        &#125;        public final K getKey()        &#123; return key; &#125;        public final V getValue()      &#123; return value; &#125;        public final String toString() &#123; return key + &quot;=&quot; + value; &#125;        public final int hashCode() &#123;            return Objects.hashCode(key) ^ Objects.hashCode(value);        &#125;        public final V setValue(V newValue) &#123;            V oldValue = value;            value = newValue;            return oldValue;        &#125;        public final boolean equals(Object o) &#123;            if (o == this)                return true;            if (o instanceof Map.Entry) &#123;                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;                if (Objects.equals(key, e.getKey()) &amp;&amp;                    Objects.equals(value, e.getValue()))                    return true;            &#125;            return false;        &#125;    &#125;        /**     * 对key进行hash，调用key的hashcode函数并与其右移16位后的结果做异或     * 这样做的好处在于，对于hashcode大于2的16次方的数进行重调，如果数     * 小于2的16次方则不变     * h &amp; (table.length -1) 等价于 h % table.length     * 这样做的原因是，当table的length比较小的时候，可以让高位也参与到     * hash算法中来，起到作用     */    static final int hash(Object key) &#123;        int h;        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);    &#125;    /**     * Returns x&apos;s Class if it is of the form &quot;class C implements     * Comparable&lt;C&gt;&quot;, else null.     */    static Class&lt;?&gt; comparableClassFor(Object x) &#123;        if (x instanceof Comparable) &#123;            Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;            if ((c = x.getClass()) == String.class) // bypass checks                return c;            if ((ts = c.getGenericInterfaces()) != null) &#123;                for (int i = 0; i &lt; ts.length; ++i) &#123;                    if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp;                        ((p = (ParameterizedType)t).getRawType() ==                         Comparable.class) &amp;&amp;                        (as = p.getActualTypeArguments()) != null &amp;&amp;                        as.length == 1 &amp;&amp; as[0] == c) // type arg is c                        return c;                &#125;            &#125;        &#125;        return null;    &#125;    /**     * Returns k.compareTo(x) if x matches kc (k&apos;s screened comparable     * class), else 0.     */    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) // for cast to Comparable    static int compareComparables(Class&lt;?&gt; kc, Object k, Object x) &#123;        return (x == null || x.getClass() != kc ? 0 :                ((Comparable)k).compareTo(x));    &#125;    /**     * 用1，2，4，8，16的或运算将cap的每一位设置为1，通过+1操作变为一个2的幂     * 先将数据-1，放置如果原来就是2的幂，变为2倍。     */    static final int tableSizeFor(int cap) &#123;        int n = cap - 1;        n |= n &gt;&gt;&gt; 1;        n |= n &gt;&gt;&gt; 2;        n |= n &gt;&gt;&gt; 4;        n |= n &gt;&gt;&gt; 8;        n |= n &gt;&gt;&gt; 16;        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;    &#125;    /* ---------------- Fields -------------- */    /**     * 哈希桶     */    transient Node&lt;K,V&gt;[] table;    /**     * 以一个个键值对为对象的集合     */    transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;    /**     * map中包含的键值对的数量     */    transient int size;    /**     * 重构次数     */    transient int modCount;    /**     * 最多能够容纳的键值对数量，threshold = length * Load factor     */    int threshold;    /**     * 负载因子，可以大于1     */    final float loadFactor;    /* ---------------- Public operations -------------- */    /**     * 容量和装载因子做参数     */    public HashMap(int initialCapacity, float loadFactor) &#123;        if (initialCapacity &lt; 0)            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                                               initialCapacity);        if (initialCapacity &gt; MAXIMUM_CAPACITY)            initialCapacity = MAXIMUM_CAPACITY;        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                                               loadFactor);        this.loadFactor = loadFactor;        this.threshold = tableSizeFor(initialCapacity);    &#125;    /**     * 默认装载因子     */    public HashMap(int initialCapacity) &#123;        this(initialCapacity, DEFAULT_LOAD_FACTOR);    &#125;    /**     * 全采用默认值     */    public HashMap() &#123;        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted    &#125;    /**     * 默认装载因子，添加参数中所有元素     */    public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;        this.loadFactor = DEFAULT_LOAD_FACTOR;        putMapEntries(m, false);    &#125;    /**     * 第二个参数在是初始化时调用此方法用false     */    final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;        int s = m.size();        if (s &gt; 0) &#123;            if (table == null) &#123; // pre-size                float ft = ((float)s / loadFactor) + 1.0F;                int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?                         (int)ft : MAXIMUM_CAPACITY);                if (t &gt; threshold)                    threshold = tableSizeFor(t);            &#125;            else if (s &gt; threshold)                resize();            for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;                K key = e.getKey();                V value = e.getValue();                putVal(hash(key), key, value, false, evict);            &#125;        &#125;    &#125;    public int size() &#123;        return size;    &#125;    public boolean isEmpty() &#123;        return size == 0;    &#125;        public V get(Object key) &#123;        Node&lt;K,V&gt; e;        return (e = getNode(hash(key), key)) == null ? null : e.value;    &#125;    /**     * 获取此节点，获取索引地址，对比第一个元素，不是的话判断是否是红黑树，是树     * 就调用树的方法继续找，不是树就循环遍历     */    final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;            (first = tab[(n - 1) &amp; hash]) != null) &#123;            if (first.hash == hash &amp;&amp; // always check first node                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))                return first;            if ((e = first.next) != null) &#123;                if (first instanceof TreeNode)                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);                do &#123;                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                        return e;                &#125; while ((e = e.next) != null);            &#125;        &#125;        return null;    &#125;        public boolean containsKey(Object key) &#123;        return getNode(hash(key), key) != null;    &#125;    public V put(K key, V value) &#123;        return putVal(hash(key), key, value, false, true);    &#125;    /**     * 判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；     * 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加     * 如果不为null，判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，这里的相同     * 指的是hashCode以及equals；     * 判断table[i] 是否为treeNode，即table[i]是否是红黑树，如果是红黑树，则直接在树中插入     * 键值对     * 遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入     * 操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；     * 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行     * 扩容。     */    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                   boolean evict) &#123;        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;        if ((tab = table) == null || (n = tab.length) == 0)            n = (tab = resize()).length;        if ((p = tab[i = (n - 1) &amp; hash]) == null)            tab[i] = newNode(hash, key, value, null);        else &#123;            Node&lt;K,V&gt; e; K k;            if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))                e = p;            else if (p instanceof TreeNode)                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);            else &#123;                for (int binCount = 0; ; ++binCount) &#123;                    if ((e = p.next) == null) &#123;                        p.next = newNode(hash, key, value, null);                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                            treeifyBin(tab, hash);                        break;                    &#125;                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                        break;                    p = e;                &#125;            &#125;            if (e != null) &#123; // existing mapping for key                V oldValue = e.value;                if (!onlyIfAbsent || oldValue == null)                    e.value = value;                afterNodeAccess(e);                return oldValue;            &#125;        &#125;        ++modCount;        if (++size &gt; threshold)            resize();        afterNodeInsertion(evict);        return null;    &#125;    /**     * resize是最核心的扩展方法，开始的时候判断oldCap即老数组长度，如果不是0的话在范围合理     * 的情况下进行扩展，如果范围不合理就不能再扩展了。如果老数组长度为0，说明table还没初始     * 化，如果老threshold不为零说明初始化的时候定义了容量，就采用这个容量，如果什么都没定     * 义，就都用默认的。这一步完成即完成了threshold的设置，table的创建。     *      * 之后创建一个新table，遍历老table把所有对象引用制null等待回收，根据情况判断，如果只有     * 一个节点就直接放进去，如果是红黑树就调用方法，如果是链表就循环遍历，重新hash。     *     * 因为采用2的幂做容量，所以当进行（n-1）&amp; hashcode的时候只需要判断一个高位是0还是1。     */    final Node&lt;K,V&gt;[] resize() &#123;        Node&lt;K,V&gt;[] oldTab = table;        int oldCap = (oldTab == null) ? 0 : oldTab.length;        int oldThr = threshold;        int newCap, newThr = 0;        if (oldCap &gt; 0) &#123;            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;                threshold = Integer.MAX_VALUE;                return oldTab;            &#125;            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)                newThr = oldThr &lt;&lt; 1; // double threshold        &#125;        else if (oldThr &gt; 0) // initial capacity was placed in threshold            newCap = oldThr;        else &#123;               // zero initial threshold signifies using defaults            newCap = DEFAULT_INITIAL_CAPACITY;            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);        &#125;        if (newThr == 0) &#123;            float ft = (float)newCap * loadFactor;            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                      (int)ft : Integer.MAX_VALUE);        &#125;        threshold = newThr;        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];        table = newTab;        if (oldTab != null) &#123;            for (int j = 0; j &lt; oldCap; ++j) &#123;                Node&lt;K,V&gt; e;                if ((e = oldTab[j]) != null) &#123;                    oldTab[j] = null;                    if (e.next == null)                        newTab[e.hash &amp; (newCap - 1)] = e;                    else if (e instanceof TreeNode)                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                    else &#123; // preserve order                        Node&lt;K,V&gt; loHead = null, loTail = null;                        Node&lt;K,V&gt; hiHead = null, hiTail = null;                        Node&lt;K,V&gt; next;                        do &#123;                            next = e.next;                            if ((e.hash &amp; oldCap) == 0) &#123;                                if (loTail == null)                                    loHead = e;                                else                                    loTail.next = e;                                loTail = e;                            &#125;                            else &#123;                                if (hiTail == null)                                    hiHead = e;                                else                                    hiTail.next = e;                                hiTail = e;                            &#125;                        &#125; while ((e = next) != null);                        if (loTail != null) &#123;                            loTail.next = null;                            newTab[j] = loHead;                        &#125;                        if (hiTail != null) &#123;                            hiTail.next = null;                            newTab[j + oldCap] = hiHead;                        &#125;                    &#125;                &#125;            &#125;        &#125;        return newTab;    &#125;    /**     * 转换成红黑树     */    final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;        int n, index; Node&lt;K,V&gt; e;        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)            resize();        else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;            TreeNode&lt;K,V&gt; hd = null, tl = null;            do &#123;                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);                if (tl == null)                    hd = p;                else &#123;                    p.prev = tl;                    tl.next = p;                &#125;                tl = p;            &#125; while ((e = e.next) != null);            if ((tab[index] = hd) != null)                hd.treeify(tab);        &#125;    &#125;    public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123;        putMapEntries(m, true);    &#125;    public V remove(Object key) &#123;        Node&lt;K,V&gt; e;        return (e = removeNode(hash(key), key, null, false, true)) == null ?            null : e.value;    &#125;    /**     * 删除元素，删除的操作流程类似于put     */    final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,                               boolean matchValue, boolean movable) &#123;        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;            (p = tab[index = (n - 1) &amp; hash]) != null) &#123;            Node&lt;K,V&gt; node = null, e; K k; V v;            if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))                node = p;            else if ((e = p.next) != null) &#123;                if (p instanceof TreeNode)                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);                else &#123;                    do &#123;                        if (e.hash == hash &amp;&amp;                            ((k = e.key) == key ||                             (key != null &amp;&amp; key.equals(k)))) &#123;                            node = e;                            break;                        &#125;                        p = e;                    &#125; while ((e = e.next) != null);                &#125;            &#125;            if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||                                 (value != null &amp;&amp; value.equals(v)))) &#123;                if (node instanceof TreeNode)                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);                else if (node == p)                    tab[index] = node.next;                else                    p.next = node.next;                ++modCount;                --size;                afterNodeRemoval(node);                return node;            &#125;        &#125;        return null;    &#125;    public void clear() &#123;        Node&lt;K,V&gt;[] tab;        modCount++;        if ((tab = table) != null &amp;&amp; size &gt; 0) &#123;            size = 0;            for (int i = 0; i &lt; tab.length; ++i)                tab[i] = null;        &#125;    &#125;    public boolean containsValue(Object value) &#123;        Node&lt;K,V&gt;[] tab; V v;        if ((tab = table) != null &amp;&amp; size &gt; 0) &#123;            for (int i = 0; i &lt; tab.length; ++i) &#123;                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123;                    if ((v = e.value) == value ||                        (value != null &amp;&amp; value.equals(v)))                        return true;                &#125;            &#125;        &#125;        return false;    &#125;\n2 TreeMapHashMap是使用哈希法进行数据存储的映射类，而TreeMap顾名思义，是按照树这种数据结构存储的映射类。相比较HashMap，TreeMap能够对存放的元素按照key进行排序操作，提供返回当前元素的上一个元素、下一个元素等操作。\n2.1 特性\nTreeMap通过红黑树实现，红黑树结合了平衡二叉树的平衡性和普通二叉树插入删除的效率，是一种在增删改查四种操作下都能保持一定效率的二叉树\nTreeMap是非同步的\n因为是根据红黑树实现，所以TreeMap可以根据当前元素很方便的查找上一个、下一个元素\n\nTreeMap因为实现的复杂性，源代码较长这里就不展开了。\n3 LinkedHashMapHashMap是无序的，有时业务需要我们记录HashMap的顺序性。此时我们可以使用LinkedHashMap，它虽然增加了时间和空间上的开销，但通过维护一个双向链表，保证了元素迭代的顺序。该迭代顺序可以是插入顺序或者是访问顺序。\n3.1 特性\nLinkedHashMap可以认为是HashMap+LinkedList，即它既使用HashMap操作数据结构，又使用LinkedList维护插入元素的先后顺序\nLinkedHashMap中Key和Value都允许为null\nLinkedHashMap是非线程安全的数据结构\n\n3.2 WeakHashMapWeakHashMap是对HashMap的扩展，在WeakHashMap中\n3.3 为什么需要WeakHashMap？思考这样一件事情：“在HashMap中我们通过key持有了value对象，所以除非HashMap被回收否则value对象一直是可达的”。听起来这种引用无可厚非，但是在实际业务中，有时我们把数据存放进去后不会再使用，而GC对HashMap中存在的对象又无法回收，间接导致了“内存泄漏”问题，实际上，当HashMap被回收时所有的对象都会被回收，但HashMap如果不被回收呢？那么这部分空间永远不会被使用了，也就是“泄漏”了。\n4 HashTable5 SetSet是集合的概念，我们可以向其中存放元素并通过查询判断集合中是否有某个元素，集合中的元素不能重复。具体的实现类有HashSet、TreeSet、LinkedHashSet等。不仅仅是名字和Map相似，实际上，Set的各个类都是通过Map的key来实现的。Map的key表示键是不重复的，这个概念和集合中的元素是类似的，所以Set只是对Map的key进行了封装。\n虽然Set是用Map来实现的，也并不意味着所有使用Set的地方就需要使用Map来替换，理论上它们表述的是两种概念，虽然实现上Map更强大，但在逻辑上需要使用Set时，用它能更好的表述“集合”这一概念，增强代码的可读性。","dateCreated":"2018-08-13T17:01:07+08:00","dateModified":"2018-08-13T19:11:22+08:00","datePublished":"2018-08-13T17:01:07+08:00","description":"HashMap是基于哈希表的Map接口的非同步实现。使用者可以将数据按照key,value键值对应的形式向HashMap中存放数据。hashmap是一种用空间换时间的数据结构，如何去定义桶的大小，是最关键的要衡量","headline":"Map类数据结构分析","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2018/08/13/Map类数据结构分析/"},"publisher":{"@type":"Organization","name":"Gwon NyeongJin","sameAs":["https://github.com/QuinnNorris","https://weibo.com/u/6556522860","https://blog.csdn.net/QuinnNorris","mailto:sei_qnz2015@126.com"],"image":"author.JPG","logo":{"@type":"ImageObject","url":"author.JPG"}},"url":"http://yoursite.com/2018/08/13/Map类数据结构分析/"}</script>
    <meta name="description" content="HashMap是基于哈希表的Map接口的非同步实现。使用者可以将数据按照key,value键值对应的形式向HashMap中存放数据。hashmap是一种用空间换时间的数据结构，如何去定义桶的大小，是最关键的要衡量">
<meta property="og:type" content="blog">
<meta property="og:title" content="Map类数据结构分析">
<meta property="og:url" content="http://yoursite.com/2018/08/13/Map类数据结构分析/index.html">
<meta property="og:site_name" content="Gwon NyeongJin">
<meta property="og:description" content="HashMap是基于哈希表的Map接口的非同步实现。使用者可以将数据按照key,value键值对应的形式向HashMap中存放数据。hashmap是一种用空间换时间的数据结构，如何去定义桶的大小，是最关键的要衡量">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2018-08-13T11:11:22.848Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Map类数据结构分析">
<meta name="twitter:description" content="HashMap是基于哈希表的Map接口的非同步实现。使用者可以将数据按照key,value键值对应的形式向HashMap中存放数据。hashmap是一种用空间换时间的数据结构，如何去定义桶的大小，是最关键的要衡量">
<meta name="twitter:creator" content="@tranquilpeak">
    
        <link rel="publisher" href="https://plus.google.com/123812884128439"/>
    
    
        
    
    
        <meta property="og:image" content="http://yoursite.com/assets/images/author.JPG"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-i6ocru2zygmpjl8otphcdx6snlgtyoe61xyhbznuhlf9oecygf3ve5rt8fpi.min.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Gwon NyeongJin</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/author.JPG" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/author.JPG" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">Gwon NyeongJin</h4>
                
                    <h5 class="sidebar-profile-bio"><p>桃李春风一杯酒，江湖夜雨十年灯</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="春山如笑"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">春山如笑</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="火树银花"
                        >
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">火树银花</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="晓风残月"
                        >
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">晓风残月</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="飞鸿印雪"
                        >
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">飞鸿印雪</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/QuinnNorris" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://weibo.com/u/6556522860" target="_blank" rel="noopener" title="Weibo">
                    
                        <i class="sidebar-button-icon fab fa-weibo" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Weibo</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://blog.csdn.net/QuinnNorris" target="_blank" rel="noopener" title="CSDN">
                    
                        <i class="sidebar-button-icon fab fa-cuttlefish" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">CSDN</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:sei_qnz2015@126.com" target="_blank" rel="noopener" title="E-mail">
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">E-mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-center">
    
        <h1 class="post-title">
            Map类数据结构分析
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2018-08-13T17:01:07+08:00">
	
		    8月 13, 2018
    	
    </time>
    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <!-- excerpt --></p>
<h2 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1 HashMap"></a>1 HashMap</h2><p>HashMap是基于哈希表的Map接口的非同步实现。使用者可以将数据按照key,value键值对应的形式向HashMap中存放数据。hashmap是一种用空间换时间的数据结构，如何去定义桶的大小，是最关键的要衡量的指标。如果桶过大，则空间浪费，如果桶过小，则会频繁发生冲突。</p>
<h3 id="1-2特性"><a href="#1-2特性" class="headerlink" title="1.2特性"></a>1.2特性</h3><ol>
<li>容量大小必须为2的幂，h &amp; (table.length -1) 等价于 h % table.length</li>
<li>具有装载因子的概念，默认为0.75</li>
<li>对key进行hash，调用key的hashcode函数并与其右移16位后的结果做异或</li>
<li>对于用户声明的容量，HashMap的容量会变为大于此容量的最小的2的幂</li>
<li>HashMap采用懒加载，put方法会依次进行：创建数组、是否扩容、添加数据的操作</li>
<li>一般情况下，遇到哈希冲突可以采用开放定址法或者使用拉链法两种方法解决。HashMap采用拉链法解决冲突</li>
<li>不保证映射的顺序，特别是它不保证该顺序恒久不变</li>
<li>扩容非常方便，在一个桶中的数据会被存放在两个桶中</li>
<li>HashMap中允许存放并使用null值和null键</li>
<li>调用put方法，会计算其中put的key的对象的hashcode，通过类中的hash函数运算进行处理，处理后在桶中找到这个地址，存放进链表的尾部</li>
<li>HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)</li>
</ol>
<h3 id="1-3-源代码分析"><a href="#1-3-源代码分析" class="headerlink" title="1.3 源代码分析"></a>1.3 源代码分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 362498820763181265L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 容量大小必须为2的幂，原因是从jdk1.2开始之后计算机中除法、取模</span><br><span class="line">     * 运算操作效率越来越低，为了防止效率过低，设置容量大小为2的幂，</span><br><span class="line">     * 在进行取模时，用A&amp;（B-1）来代替A%B的操作，提高效率，至于hash分布</span><br><span class="line">     * 用其他的辅助方法确保效率</span><br><span class="line">     */</span><br><span class="line">    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 最大容量2的29次方</span><br><span class="line">     */</span><br><span class="line">    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加载因子</span><br><span class="line">     */</span><br><span class="line">    static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line"></span><br><span class="line">    static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line"></span><br><span class="line">    static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line"></span><br><span class="line">    static final int MIN_TREEIFY_CAPACITY = 64;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * hashMap桶中的数据结构是Node，next是下一个Node的引用</span><br><span class="line">     */</span><br><span class="line">    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            this.hash = hash;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final K getKey()        &#123; return key; &#125;</span><br><span class="line">        public final V getValue()      &#123; return value; &#125;</span><br><span class="line">        public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</span><br><span class="line"></span><br><span class="line">        public final int hashCode() &#123;</span><br><span class="line">            return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final V setValue(V newValue) &#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final boolean equals(Object o) &#123;</span><br><span class="line">            if (o == this)</span><br><span class="line">                return true;</span><br><span class="line">            if (o instanceof Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 对key进行hash，调用key的hashcode函数并与其右移16位后的结果做异或</span><br><span class="line">     * 这样做的好处在于，对于hashcode大于2的16次方的数进行重调，如果数</span><br><span class="line">     * 小于2的16次方则不变</span><br><span class="line">     * h &amp; (table.length -1) 等价于 h % table.length</span><br><span class="line">     * 这样做的原因是，当table的length比较小的时候，可以让高位也参与到</span><br><span class="line">     * hash算法中来，起到作用</span><br><span class="line">     */</span><br><span class="line">    static final int hash(Object key) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns x&apos;s Class if it is of the form &quot;class C implements</span><br><span class="line">     * Comparable&lt;C&gt;&quot;, else null.</span><br><span class="line">     */</span><br><span class="line">    static Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">        if (x instanceof Comparable) &#123;</span><br><span class="line">            Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">            if ((c = x.getClass()) == String.class) // bypass checks</span><br><span class="line">                return c;</span><br><span class="line">            if ((ts = c.getGenericInterfaces()) != null) &#123;</span><br><span class="line">                for (int i = 0; i &lt; ts.length; ++i) &#123;</span><br><span class="line">                    if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp;</span><br><span class="line">                        ((p = (ParameterizedType)t).getRawType() ==</span><br><span class="line">                         Comparable.class) &amp;&amp;</span><br><span class="line">                        (as = p.getActualTypeArguments()) != null &amp;&amp;</span><br><span class="line">                        as.length == 1 &amp;&amp; as[0] == c) // type arg is c</span><br><span class="line">                        return c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns k.compareTo(x) if x matches kc (k&apos;s screened comparable</span><br><span class="line">     * class), else 0.</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) // for cast to Comparable</span><br><span class="line">    static int compareComparables(Class&lt;?&gt; kc, Object k, Object x) &#123;</span><br><span class="line">        return (x == null || x.getClass() != kc ? 0 :</span><br><span class="line">                ((Comparable)k).compareTo(x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用1，2，4，8，16的或运算将cap的每一位设置为1，通过+1操作变为一个2的幂</span><br><span class="line">     * 先将数据-1，放置如果原来就是2的幂，变为2倍。</span><br><span class="line">     */</span><br><span class="line">    static final int tableSizeFor(int cap) &#123;</span><br><span class="line">        int n = cap - 1;</span><br><span class="line">        n |= n &gt;&gt;&gt; 1;</span><br><span class="line">        n |= n &gt;&gt;&gt; 2;</span><br><span class="line">        n |= n &gt;&gt;&gt; 4;</span><br><span class="line">        n |= n &gt;&gt;&gt; 8;</span><br><span class="line">        n |= n &gt;&gt;&gt; 16;</span><br><span class="line">        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* ---------------- Fields -------------- */</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 哈希桶</span><br><span class="line">     */</span><br><span class="line">    transient Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 以一个个键值对为对象的集合</span><br><span class="line">     */</span><br><span class="line">    transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * map中包含的键值对的数量</span><br><span class="line">     */</span><br><span class="line">    transient int size;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重构次数</span><br><span class="line">     */</span><br><span class="line">    transient int modCount;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 最多能够容纳的键值对数量，threshold = length * Load factor</span><br><span class="line">     */</span><br><span class="line">    int threshold;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 负载因子，可以大于1</span><br><span class="line">     */</span><br><span class="line">    final float loadFactor;</span><br><span class="line"></span><br><span class="line">    /* ---------------- Public operations -------------- */</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 容量和装载因子做参数</span><br><span class="line">     */</span><br><span class="line">    public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        this.loadFactor = loadFactor;</span><br><span class="line">        this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 默认装载因子</span><br><span class="line">     */</span><br><span class="line">    public HashMap(int initialCapacity) &#123;</span><br><span class="line">        this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 全采用默认值</span><br><span class="line">     */</span><br><span class="line">    public HashMap() &#123;</span><br><span class="line">        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 默认装载因子，添加参数中所有元素</span><br><span class="line">     */</span><br><span class="line">    public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 第二个参数在是初始化时调用此方法用false</span><br><span class="line">     */</span><br><span class="line">    final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;</span><br><span class="line">        int s = m.size();</span><br><span class="line">        if (s &gt; 0) &#123;</span><br><span class="line">            if (table == null) &#123; // pre-size</span><br><span class="line">                float ft = ((float)s / loadFactor) + 1.0F;</span><br><span class="line">                int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (int)ft : MAXIMUM_CAPACITY);</span><br><span class="line">                if (t &gt; threshold)</span><br><span class="line">                    threshold = tableSizeFor(t);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (s &gt; threshold)</span><br><span class="line">                resize();</span><br><span class="line">            for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">                K key = e.getKey();</span><br><span class="line">                V value = e.getValue();</span><br><span class="line">                putVal(hash(key), key, value, false, evict);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return size == 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取此节点，获取索引地址，对比第一个元素，不是的话判断是否是红黑树，是树</span><br><span class="line">     * 就调用树的方法继续找，不是树就循环遍历</span><br><span class="line">     */</span><br><span class="line">    final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">            if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                return first;</span><br><span class="line">            if ((e = first.next) != null) &#123;</span><br><span class="line">                if (first instanceof TreeNode)</span><br><span class="line">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        return e;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean containsKey(Object key) &#123;</span><br><span class="line">        return getNode(hash(key), key) != null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public V put(K key, V value) &#123;</span><br><span class="line">        return putVal(hash(key), key, value, false, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</span><br><span class="line">     * 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加</span><br><span class="line">     * 如果不为null，判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，这里的相同</span><br><span class="line">     * 指的是hashCode以及equals；</span><br><span class="line">     * 判断table[i] 是否为treeNode，即table[i]是否是红黑树，如果是红黑树，则直接在树中插入</span><br><span class="line">     * 键值对</span><br><span class="line">     * 遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入</span><br><span class="line">     * 操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</span><br><span class="line">     * 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行</span><br><span class="line">     * 扩容。</span><br><span class="line">     */</span><br><span class="line">    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">        else &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            if (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;</span><br><span class="line">                for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                    if ((e = p.next) == null) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, null);</span><br><span class="line">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (e != null) &#123; // existing mapping for key</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * resize是最核心的扩展方法，开始的时候判断oldCap即老数组长度，如果不是0的话在范围合理</span><br><span class="line">     * 的情况下进行扩展，如果范围不合理就不能再扩展了。如果老数组长度为0，说明table还没初始</span><br><span class="line">     * 化，如果老threshold不为零说明初始化的时候定义了容量，就采用这个容量，如果什么都没定</span><br><span class="line">     * 义，就都用默认的。这一步完成即完成了threshold的设置，table的创建。</span><br><span class="line">     * </span><br><span class="line">     * 之后创建一个新table，遍历老table把所有对象引用制null等待回收，根据情况判断，如果只有</span><br><span class="line">     * 一个节点就直接放进去，如果是红黑树就调用方法，如果是链表就循环遍历，重新hash。</span><br><span class="line">     *</span><br><span class="line">     * 因为采用2的幂做容量，所以当进行（n-1）&amp; hashcode的时候只需要判断一个高位是0还是1。</span><br><span class="line">     */</span><br><span class="line">    final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">        int oldThr = threshold;</span><br><span class="line">        int newCap, newThr = 0;</span><br><span class="line">        if (oldCap &gt; 0) &#123;</span><br><span class="line">            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                return oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">        &#125;</span><br><span class="line">        else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        if (newThr == 0) &#123;</span><br><span class="line">            float ft = (float)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        if (oldTab != null) &#123;</span><br><span class="line">            for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                    oldTab[j] = null;</span><br><span class="line">                    if (e.next == null)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                    else if (e instanceof TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                    else &#123; // preserve order</span><br><span class="line">                        Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        do &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                                if (loTail == null)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if (hiTail == null)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; while ((e = next) != null);</span><br><span class="line">                        if (loTail != null) &#123;</span><br><span class="line">                            loTail.next = null;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (hiTail != null) &#123;</span><br><span class="line">                            hiTail.next = null;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 转换成红黑树</span><br><span class="line">     */</span><br><span class="line">    final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">        int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line">        else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">            do &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);</span><br><span class="line">                if (tl == null)</span><br><span class="line">                    hd = p;</span><br><span class="line">                else &#123;</span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">            if ((tab[index] = hd) != null)</span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        putMapEntries(m, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public V remove(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        return (e = removeNode(hash(key), key, null, false, true)) == null ?</span><br><span class="line">            null : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除元素，删除的操作流程类似于put</span><br><span class="line">     */</span><br><span class="line">    final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,</span><br><span class="line">                               boolean matchValue, boolean movable) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</span><br><span class="line">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = null, e; K k; V v;</span><br><span class="line">            if (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            else if ((e = p.next) != null) &#123;</span><br><span class="line">                if (p instanceof TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                else &#123;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        if (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; while ((e = e.next) != null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != null &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                if (node instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);</span><br><span class="line">                else if (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                else</span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        modCount++;</span><br><span class="line">        if ((tab = table) != null &amp;&amp; size &gt; 0) &#123;</span><br><span class="line">            size = 0;</span><br><span class="line">            for (int i = 0; i &lt; tab.length; ++i)</span><br><span class="line">                tab[i] = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean containsValue(Object value) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">        if ((tab = table) != null &amp;&amp; size &gt; 0) &#123;</span><br><span class="line">            for (int i = 0; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123;</span><br><span class="line">                    if ((v = e.value) == value ||</span><br><span class="line">                        (value != null &amp;&amp; value.equals(v)))</span><br><span class="line">                        return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-TreeMap"><a href="#2-TreeMap" class="headerlink" title="2 TreeMap"></a>2 TreeMap</h2><p>HashMap是使用哈希法进行数据存储的映射类，而TreeMap顾名思义，是按照树这种数据结构存储的映射类。相比较HashMap，TreeMap能够对存放的元素按照key进行排序操作，提供返回当前元素的上一个元素、下一个元素等操作。</p>
<h3 id="2-1-特性"><a href="#2-1-特性" class="headerlink" title="2.1 特性"></a>2.1 特性</h3><ol>
<li>TreeMap通过红黑树实现，红黑树结合了平衡二叉树的平衡性和普通二叉树插入删除的效率，是一种在增删改查四种操作下都能保持一定效率的二叉树</li>
<li>TreeMap是非同步的</li>
<li>因为是根据红黑树实现，所以TreeMap可以根据当前元素很方便的查找上一个、下一个元素</li>
</ol>
<p>TreeMap因为实现的复杂性，源代码较长这里就不展开了。</p>
<h2 id="3-LinkedHashMap"><a href="#3-LinkedHashMap" class="headerlink" title="3 LinkedHashMap"></a>3 LinkedHashMap</h2><p>HashMap是无序的，有时业务需要我们记录HashMap的顺序性。此时我们可以使用LinkedHashMap，它虽然增加了时间和空间上的开销，但通过维护一个双向链表，保证了元素迭代的顺序。该迭代顺序可以是插入顺序或者是访问顺序。</p>
<h3 id="3-1-特性"><a href="#3-1-特性" class="headerlink" title="3.1 特性"></a>3.1 特性</h3><ol>
<li>LinkedHashMap可以认为是HashMap+LinkedList，即它既使用HashMap操作数据结构，又使用LinkedList维护插入元素的先后顺序</li>
<li>LinkedHashMap中Key和Value都允许为null</li>
<li>LinkedHashMap是非线程安全的数据结构</li>
</ol>
<h3 id="3-2-WeakHashMap"><a href="#3-2-WeakHashMap" class="headerlink" title="3.2 WeakHashMap"></a>3.2 WeakHashMap</h3><p>WeakHashMap是对HashMap的扩展，在WeakHashMap中</p>
<h3 id="3-3-为什么需要WeakHashMap？"><a href="#3-3-为什么需要WeakHashMap？" class="headerlink" title="3.3 为什么需要WeakHashMap？"></a>3.3 为什么需要WeakHashMap？</h3><p>思考这样一件事情：“在HashMap中我们通过key持有了value对象，所以除非HashMap被回收否则value对象一直是可达的”。听起来这种引用无可厚非，但是在实际业务中，有时我们把数据存放进去后不会再使用，而GC对HashMap中存在的对象又无法回收，间接导致了“内存泄漏”问题，实际上，当HashMap被回收时所有的对象都会被回收，但HashMap如果不被回收呢？那么这部分空间永远不会被使用了，也就是“泄漏”了。</p>
<h2 id="4-HashTable"><a href="#4-HashTable" class="headerlink" title="4 HashTable"></a>4 HashTable</h2><h2 id="5-Set"><a href="#5-Set" class="headerlink" title="5 Set"></a>5 Set</h2><p>Set是集合的概念，我们可以向其中存放元素并通过查询判断集合中是否有某个元素，集合中的元素不能重复。具体的实现类有HashSet、TreeSet、LinkedHashSet等。不仅仅是名字和Map相似，实际上，Set的各个类都是通过Map的key来实现的。Map的key表示键是不重复的，这个概念和集合中的元素是类似的，所以Set只是对Map的key进行了封装。</p>
<p>虽然Set是用Map来实现的，也并不意味着所有使用Set的地方就需要使用Map来替换，理论上它们表述的是两种概念，虽然实现上Map更强大，但在逻辑上需要使用Set时，用它能更好的表述“集合”这一概念，增强代码的可读性。</p>
            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--disabled">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/13/常用列表数据结构比较/" data-tooltip="常用列表数据结构比较" aria-label="下一篇: 常用列表数据结构比较">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://yoursite.com/2018/08/13/Map类数据结构分析/" title="分享到 Weibo">
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2018/08/13/Map类数据结构分析/&amp;title=Map类数据结构分析" title="分享到 QQ">
                    <i class="fab fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://yoursite.com/2018/08/13/Map类数据结构分析/" title="分享到 Qzone">
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a class="post-action-btn btn btn--default" href="#gitment">
                         <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="gitment"></div>
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2018 Gwon NyeongJin. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--disabled">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/13/常用列表数据结构比较/" data-tooltip="常用列表数据结构比较" aria-label="下一篇: 常用列表数据结构比较">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://yoursite.com/2018/08/13/Map类数据结构分析/" title="分享到 Weibo">
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2018/08/13/Map类数据结构分析/&amp;title=Map类数据结构分析" title="分享到 QQ">
                    <i class="fab fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://yoursite.com/2018/08/13/Map类数据结构分析/" title="分享到 Qzone">
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a class="post-action-btn btn btn--default" href="#gitment">
                         <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="4">
    <i id="btn-close-shareoptions" class="fa fa-times"></i>
    <ul class="share-options">
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://yoursite.com/2018/08/13/Map类数据结构分析/">
                    <i class="fab fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2018/08/13/Map类数据结构分析/&amp;title=Map类数据结构分析">
                    <i class="fab fa-qq" aria-hidden="true"></i><span>分享到 QQ</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://yoursite.com/2018/08/13/Map类数据结构分析/">
                    <i class="fa fa-star" aria-hidden="true"></i><span>分享到 Qzone</span>
                </a>
            </li>
        
    </ul>
</div>

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/author.JPG" alt="作者的图片"/>
        
            <h4 id="about-card-name">Gwon NyeongJin</h4>
        
            <div id="about-card-bio"><p>桃李春风一杯酒，江湖夜雨十年灯</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>student,ECNU</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                ShangHai,China
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-qzbgadpdnlugjrqdjaujv4vz8hkcaii0bwe38klalkynjw9ejqnx8lcst13k.min.js"></script>
<!--SCRIPTS END-->

    
        <script type="text/javascript">
            (function() {
                function render() {
                    new Gitment({
                        id: 'http://yoursite.com/2018/08/13/Map类数据结构分析/',
                        owner: 'QuinnNorris',
                        repo: 'QuinnNorris.github.io',
                        oauth: {
                            client_id: '0e7c41f03dfb1c28ea35',
                            client_secret: '3220af0710c19324499245a612c05094f6ee3321',
                        }
                    }).render('gitment');
                }
                var gc = document.createElement('script');
                gc.type = 'text/javascript';
                gc.src = '//imsun.github.io/gitment/dist/gitment.browser.js';
                gc.charset = 'UTF-8';
                gc.onload = render;
                gc.async = true;
                document.querySelector('body').appendChild(gc);
                var gcs = document.createElement('link');
                gcs.href = '//imsun.github.io/gitment/style/default.css';
                gcs.type = 'text/css';
                gcs.rel = 'stylesheet';
                gcs.media = 'screen,print';
                document.querySelector('head').appendChild(gcs);
            })();
	    </script>
    



    </body>
</html>
